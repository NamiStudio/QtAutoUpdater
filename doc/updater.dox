/*!
@class QtAutoUpdater::Updater

The updater class has the task to run the maintenancetool to check for updates. It will
evalute the results of the tool and generate update information of it. In addition of that,
it can schedule the maintenancetool to run in updater mode as soon as the application
finishes. (This requires the Updater instance to exist until QCoreApplication::quit is called).

@sa @ref index "REAMDE.md", QtAutoUpdater::UpdateController
*/

/*!
@property QtAutoUpdater::Updater::maintenanceToolPath

@default{`./maintenancetool` on Windows/X11, `../../maintenancetool` on mac}

The path of the maintenancetool has to be set inside of the constructor and cannot be
changed later. The same goes for the Updater::updaterType. You can use the Updater::isValid
method to check if the given tool and type are valid.

The updater type decides which plugin to load as backend for the updater. The default
one is the "qtifw" backend, which supports update checks via the Qt Installer Framework (QtIFW).
The maintenancetool path is passed to that plugin the get an instance for the given updater.

Depending on the updater backend type you choose, that path can be something sligthly different,
check the documentation of those in that case.

<b>For QtIFW Updaters:</b><br/>
The path will be resolved relative to QCoreApplication::applicationDirPath(), the location
of the currently running application.

The updater will check whether or not the given path has a file-extension. If not, it
will try to add the given extension. This will result into:

 - **Windows**: `./maintenancetool.exe` (e.g. `C:/Program Files/MyApp/maintenancetool.exe`)
 - **Mac**: `../../maintenancetool.app/Content/MacOS/maintenancetool` (e.g. `/Applications/MyApp.app/maintenancetool.app/Content/MacOS/maintenancetool`)
 - **X11**: `./maintenancetool` (unchanged, e.g. `/opt/MyApp/maintenancetool`)

@accessors{
	@readAc{maintenanceToolPath()}
	@constantAc
	@finalAc
}

@sa Updater::isValid, Updater::updaterType, Updater::Updater
*/

/*!
@property QtAutoUpdater::Updater::state

@default{`Updater::NoUpdates`}

The updater can only check for updates once at a time. If this property returns `Updater::Running`,
you will have to wait for it to finish to get your update result or check for updates again.
The other states describe the possible results of an update check.

@accessors{
	@readAc{state()}
	@notifyAc{stateChanged()}
}

@sa Updater::checkForUpdates, Updater::abortUpdateCheck, Updater::UpdaterState, Updater::errorLog
*/

/*!
@property QtAutoUpdater::Updater::updateInfo

@default{<i>&lt;empty list&gt;</i>}

The update result is only valid for the last update check and won't be updated until
you check for updates again. When checking for updates, the list will be cleared before
the updater starts the check.<br/>
To find out whether the list is truly empty or just because the updater is running, use
the Updater::state property. If it returns anything but `Updater::Running`, you can assume that the value of this
property is the result of the last update check (if one happend).

@accessors{
	@readAc{updateInfo()}
	@notifyAc{updateInfoChanged()}
}

@sa Updater::state
*/

/*!
@fn QtAutoUpdater::Updater::Updater(QObject *)

@param parent The object parent for QObject

The maintenancetool path will be set to the default one and the updater backend type
to "qtifw". Both cannot be changed afterwards
See Updater::maintenanceToolPath for more details.

@sa Updater::maintenanceToolPath
*/

/*!
@fn QtAutoUpdater::Updater::Updater(const QString &, QObject *)

@param maintenanceToolPath The path to the maintenancetool
@param parent The object parent for QObject

The maintenancetool path will be set to the given one and the updater backend type
to "qtifw". Both cannot be changed afterwards
See Updater::maintenanceToolPath for more details.

@sa Updater::maintenanceToolPath
*/

/*!
@fn QtAutoUpdater::Updater::Updater(const QString &, const QByteArray &, QObject *)

@param maintenanceToolPath The path to the maintenancetool
@param type The updater backend type
@param parent The object parent for QObject

The maintenancetool path and the updater backend type will be set to the given ones.
Both cannot be changed afterwards
See Updater::maintenanceToolPath for more details.

@sa Updater::maintenanceToolPath
*/

/*!
@fn QtAutoUpdater::Updater::~Updater

Desytroyes the updater. If the maintenancetool process is still running, it will be killed
(hard, not friendly). To avoid this, check if Updater::running returns `false` or use
Updater::abortUpdateCheck to gracefully shut down the maintenancetool

@sa Updater::running, Updater::abortUpdateCheck
*/

/*!
@fn QtAutoUpdater::Updater::isValid

@returns `true`, if the updater is valid

An updater is valid, if the choosen backend type exists and the corresponding plugin
allowed the given maintenancetool path. An invalid updater will not be able to do anything,
and permanently stay in the `Updater::HasError` state.

@sa Updater::state, Updater::Updater, Updater::maintenanceToolPath
*/

/*!
@fn QtAutoUpdater::Updater::updaterType

@returns The type of updater backend used

The type is set via the constructor and cannot be changed. See Updater::maintenanceToolPath
for details.

@sa Updater::Updater, Updater::maintenanceToolPath
*/

/*!
@fn QtAutoUpdater::Updater::errorString

@returns The error string in case of an error

The error string is only set when the updater is in the `Updater::HasError` state.
It can be used to retrieve details about why it is in that state

@sa Updater::state, Updater::extendedErrorLog
*/

/*!
@fn QtAutoUpdater::Updater::extendedErrorLog

@returns The error log of the last run of the maintenancetool

This function will return some kind of extended log the updater backend produces. It can
be used in both, error and normal cases, to get more information about the update process
(e.g. warnings, soft errors, etc).

@note For the "qtifw" backend, the stderr of the maintenancetool process is returned. For
other backends, this can be anything. It's possible for plugins to ignore this extra log.
In this case this method will not return anything.

@sa Updater::state, Updater::errorString
*/

/*!
@fn QtAutoUpdater::Updater::willRunOnExit

@returns `true`, if the maintenancetool will run on application exit

@sa Updater::runUpdaterOnExit, Updater::cancelExitRun
*/

/*!
@fn QtAutoUpdater::Updater::checkForUpdates

@returns `true`, if the check for updates process was started

Checking for updates means that the maintenancetool will be run in background to
check for new updates. This function returns immediatly and only reports whether the
update check was started or not.

If the updater is already in Updater::Running state, `false` will be returned and
nothing will happen.

@sa Updater::abortUpdateCheck, Updater::updateCheckDone, Updater::state,
Updater::updateInfo
*/

/*!
@fn QtAutoUpdater::Updater::abortUpdateCheck

@param maxDelay The maximum delay to wait for the process to gracefully finish

Tries to abort the update check. If no update is currently running
(not in Updater::Running state), nothing will happen.

If `maxDelay` is greater than 0, the updater will try to gracefully terminate
the process asynchronously. If the updater does not finish before the timeout,
or if the method is called with a delay of 0, it will be killed. The function
will return immediately. You can use Updater::state to find out when the process
actually finishes.

@warning In most cases there will be no side-effects of an abort. However, if the tool has to be killed,
because of no delay or a timeout, this may cause unwanted effects. As an example, you may not be able to
start the tool until you restart your system, or worst case scenario, break the installation.
If possible, do not abort the check, but instead just wait for it to finish.

@sa Updater::checkForUpdates, Updater::state
*/

/*!
@fn QtAutoUpdater::Updater::scheduleUpdate(int , bool)

@param delaySeconds The time (in seconds) to wait until the update is started
@param repeated Specifies, whether the updater should be started every `delaySeconds`
or only once
@returns The internal ID of this update task. Can be used to cancel the task

Schedules an update to be run after `delaySeconds` seconds. If `repeated` is `true`, the
updater will not just be run once, but every `delaySeconds` seconds (infinitly, until
this instance is destroyed or the task canceled).

@note After scheduling the update, you will have no way to take track of the schedule.
If the updater is already running while the task is triggered, nothing will happend.
The scheduled update will only work if this same instance of the updater is still alive
at that time.

@sa Updater::cancelScheduledUpdate, Updater::checkForUpdates
*/

/*!
@fn QtAutoUpdater::Updater::scheduleUpdate(const QDateTime &)

@param when The timepoint where the update should be started
@returns The internal ID of this update task. Can be used to cancel the task

Schedules an update to be run at `when`. If `when` is in the past, nothing will happen and
0 will be returned. The update will be started once that time is reached (assuming that
this updater instance is still alive at that timepoint).

@note After scheduling the update, you will have no way to take track of the schedule.
If the updater is already running while the task is triggered, nothing will happend.
The scheduled update will only work if this same instance of the updater is still alive
at that time.

@sa Updater::cancelScheduledUpdate, Updater::checkForUpdates
*/

/*!
@fn QtAutoUpdater::Updater::cancelScheduledUpdate

@param taskId The id of the task to be canceled

Cancels the task with the id `taskId`. If there was a task with that ID, you can be shure
that it will be canceled. If the task was not until the point you call this function, it
will not be triggered anymore.

@sa Updater::scheduleUpdat, Updater::abortUpdateCheck
*/

/*!
@fn QtAutoUpdater::Updater::runUpdaterOnExit(AdminAuthoriser *)

@param authoriser An optional admin authoriser instance to execture the updater as admin

Schedules the maintenancetool to be run on exit. This means that as soon as the
application exits, the updater will run the maintenancetool to install updates, detached.
This way you can let the user do the actual update if you found that there are new updates.

@attention For this to work, this updater instance must exist (not be deleted) until
QCoreApplication::aboutToQuit was emitted, since that's what the updater will use to
determine that the application is exiting and to start the maintenancetool. If an updater
with a run on exit is destroyed before that, a warning will be generated.

The `authoriser` is an optional parameter that can be used to provide elevated rights.
If it points to an AdminAuthoriser, that one will be used to start the maintenancetool
with elevated rights (as admin/root) instead of starting it with the current user.

If the updater is already scheduled to run on exit, this function will overwrite the
arguments and admin authorisation, i.e. the last call to this function will determine
how the updater starts. To cancel this (stop the maintenancetool from beeing started),
you cann use Updater::cancelExitRun.

@sa Updater::willRunOnExit, Updater::cancelExitRun, AdminAuthoriser
*/

/*!
@fn QtAutoUpdater::Updater::runUpdaterOnExit(const QStringList &, AdminAuthoriser *)

@param arguments The custom arguments to be passed to to the maintenancetool
@copydetails Updater::runUpdaterOnExit(AdminAuthoriser *)
*/

/*!
@fn QtAutoUpdater::Updater::cancelExitRun

Cancels the "run on exit". If the maintenancetool was scheduled to be run at exit, this
function will cancel that and nothing will happend on exit.

@sa Updater::willRunOnExit, Updater::runUpdaterOnExit
*/

/*!
@fn QtAutoUpdater::Updater::updateCheckDone

@param hasUpdates Specifies whether or not the new updates could be found

`hasUpdates` can be used to determine if there are updates. If it is set to true, you
can assume that there are updates. If it is false, either no updates are available
or something went wrong.

@sa Updater::checkForUpdates, Updater::state, Updater::updateInfo, Updater::errorString
*/
